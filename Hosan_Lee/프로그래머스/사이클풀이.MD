```

아이디어 : 

<모든 가능성을 탐색한다>

0. 모든 격자를 탐색한다.
-모든 세로를 탐색
-모든 가로를 탐색
1. 모든 격자에 대해 모든 방향으로 탐색(동서남북)

=> 모든 vertex을 탐색할때 각 동서남북으로 빛을 쏴주어야 한다.
(즉, 3중 for문을 써야한다.)

while 문을 써서 다시 원래의 vertex로 돌아올때까지 빛을 이동시킨다.

<회로 정리에 의하면, 방향성이 있고 모두가 연결되어있는 회로의 경우, 다른 회로에 포함되지 않은
vertex가 있다면 그 vertex로부터 최소한 한 개의 새로운 회로를 만들 수 있다.>

=> while True로 설정 가능하다(최소 한 개가 만들어지니까 어떻게든 break문을 빠져나올 것이다.
     종료조건은 원래 시작된 vertex로 돌아왔을 때 이고, 그때까지 while문을 반복할 때 마다 
     count를 늘려줘 사이클의 길이를 확인한다.

y, x는 모든 세로, 가로 탐색,

for i in range(4) 는 모든 방향 탐색을 위한 변수


일단 for i in range(4)부터 주목하자. i 는 시작하는 방향을 의미한다. 즉

           i = 0  
     i=2    O   i = 3
           i = 1

의 꼴이다. 

direction 과 right, left, i의 관계 :

curr_i가 0이라고 가정 :
'R'을 만났다면? right[0] 에 따라 curr_i = 3가 된다.
여기서 direction[2]는 [0,-1], 즉 x축으로 -1만큼 이동하고, y축으론 이동하지 않게 된다. 왼쪽으로 꺾인다.
(빛이 위에서부터 들어옴)

curr_i가 1이라고 가정 :
'R'을 만났다면?  right[1] 에 따라 curr_i = 2가 된다.
여기서 direction[2]는 [0,1], 즉 x축으로 1만큼 이동하고, y축으론 이동하지 않게 된다. 오른쪽으로 꺾인다.
(빛이 아래에서부터 들어옴)

이런식으로 i를 이용하여 right, left를 체크하며 방향을 바꿔 빛이 이동하는걸 구현할 수 있다,
curr_x, curr_y = (curr_x + direction[curr_i][1]) % width, (curr_y + direction[curr_i][0]) % height
height, width의 나머지로 구하는 이유는, 배열 범위를 넘어갈 시 다시 처음 인덱스로 돌아오기 위함이다.

단, 한 번 방문한 노드의 경우에는 방문 처리를 해준다.(방문 처리된 노드로부터 시작되는 사이클은 중복되니 배제하기 위함)

이런식으로 3중 for문을 돌며 모든 경우를 탐색하게 되면 모든 사이클의 길이가 배열에 저장되게 되고, 이것을 sort하여 return하게되면 정답이 나온다.

```
