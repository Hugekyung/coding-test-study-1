## 백준 1932번 정수삼각형

### 문제 설명

- 맨 위층에서 아래에 있는 수 중 하나를 선택하여 아래 층으로 내려올 때, 선택된 수의 최대합 구하기
- 현재층에서 선택된 수의 왼쪽 대각선, 오른쪽 대각선 중에서 선택해야 함

### 알고리즘

- **다이나믹 프로그래밍**

### 풀이 과정

```txt
✅ i번째 숫자에서 오른쪽 대각선에 있는 숫자와 i+1번째 숫자에서 왼쪽 대각선에 있는 숫자가 겹치면서 경로가 겹치기 때문에 윗층에서 내려오는 숫자 중에 더 큰 숫자를 더해줘야 함
➡️ 현재 인덱스가 j라면 왼쪽 위의 인덱스는 j-1, 오른쪽 위의 인덱스는 j
➡️ dp[i][j]+=max(dp[i-1][j],dp[i-1][j])
✅ 0번째 숫자, 즉 맨 왼쪽에 있는 숫자는 현재 숫자에서 오른쪽 위에 있는 숫자를 더해주면 됨. 0번째 숫자의 오른쪽 위는 윗층의 0번째 숫자
➡️ dp[i][0]+=dp[i-1][0]
✅ 만약 해당 층 오른쪽 끝에 있는 숫자라면(마지막 인덱스 숫자) 왼쪽 위에 있는 숫자를 더해주면 됨. 마지막 인덱스의 왼쪽 위는 윗층의 마지막 숫자이자 현재 층과 인덱스가 1만큼 차이남
➡️ dp[i][j]=dp[i-1][j-1]
```

### 코드 구현

사용 언어 : **파이썬**

```python
import sys
input = sys.stdin.readline
dp = []

N = int(input())
for i in range(N):
    dp.append(list(map(int, input().split())))

for i in range(1, N):
    for j in range(0, i+1):
        if j == 0:
            dp[i][j] += dp[i-1][j]
        elif j == i:
            dp[i][j] += dp[i-1][j-1]
        else:
            dp[i][j] += max(dp[i-1][j-1], dp[i-1][j])

print(max(dp[N-1]))
```
